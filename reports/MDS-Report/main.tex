\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{tcolorbox}
\usepackage{breqn}
\usepackage{adjustbox}
\usepackage{changepage}
\usepackage{rotating}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{ntheorem}
\usepackage[table_x &xcdraw]{xcolor}
\usepackage{longtable}
\usepackage{listings}
\usepackage{minted}

% Definition
\newtheorem{definition}{Definition}{\bfseries}{\itshape}
\newtheorem*{definition*}{Definition}{\bfseries}{\itshape}

% Theorem
\newtheorem{theorem}{Theorem}{\bfseries}{\itshape}

% Concept
\newtheorem*{concept}{}{\bfseries}{\itshape}

\title{A history of the application of MDS matrices in cryptography}
\author{Ana Clara Zoppi Serpa\\ Prof. Dr. Ricardo Dahab \\ Dr. Jorge Nakahara Jr.}
\date{\today}

\begin{document}
%\nocite{*} 

\maketitle

\tableofcontents

\chapter{A history of the application of MDS matrices in cryptography}

MDS matrices have been widely used in the construction of diffusion layers for block ciphers such as SHARK \cite{SHARK1996}, SQUARE \cite{SQUARE1997}, BKSQ \cite{BKSQ1998}, KHAZAD \cite{KHAZAD2000}, ANUBIS \cite{ANUBIS2000}, Hierocrypt-3 \cite{Hierocrypt2000}, Rijndael (AES) \cite{DesignOfRijndael2002} and Curupira \cite{barreto2007curupira}. They have also been applied in the design of hash functions (e.g Whirlwind \cite{Whirlwind2010} and Gr{\o}stl \cite{Grostl2009}). The choice is due to the fact that MDS codes provide transformations with optimal linear and differential branch numbers (see e.g \cite{SQUARE1997} or \cite{SHARK1996}), thus contributing to security against Differential and Linear Cryptanalysis attacks. 

When a matrix is MDS, optimal \emph{branch number} (a measure of diffusion power) is ensured, therefore, from the theoretical security perspective, any two distinct $n \times n$ MDS matrices present equal contribution to a cipher's design in terms of diffusion power. However, their computational cost, which is a relevant practical implementation criterion, \emph{is not} necessarily the same. This motivates not only the search for MDS matrices, but the search for \emph{MDS matrices with low computational cost}. In this work, the computational cost of a matrix $A$ is measured by the amount of \textbf{xor} and \textbf{xtime} operations required when multiplying a cipher's state column vector by $A$.

Due to the computational cost of matrix multiplication, there is an interest in finding MDS matrices with coefficients as small as possible, in order to minimize the required amount of \textbf{xor} and \textbf{xtime} operations required by the implementations. However, the complexity of finding MDS matrices through random search increases proportionally to the dimension, which led to the investigation of systematic methods to construct (or find) MDS matrices. One possible avenue is trying to find direct mathematical constructions which ensure the MDS property, and another is to impose restrictions to limit the random search space (e.g imposing the matrix should be circulant, as was done by the authors of \cite{SQUARE1997}). Furthermore, there is an interest in finding involutory MDS matrices (as pointed by \cite{KHAZAD2000} and \cite{ANUBIS2000}), so that the encryption and the decryption computational cost are the same.

It is also worth noting that, although MDS matrices are widely used in cryptographic algorithms, there are designs which prefer not to make use of them. The block ciphers Serpent \cite{Serpent1998}, IDEA \cite{IDEA2000} and PRESENT \cite{PRESENT2007}, for instance, do not include MDS matrices in their design. The hash function Keccak \cite{Keccak2013}, which was later selected by NIST to become the SHA-3 standard, also does not use MDS matrices. The computational cost can be related to this choice.

In this chapter, we aim at providing a history of the application of MDS matrices in cryptography, listing the matrices, the ciphers in which they have been applied, the respective Finite Fields (order and irreducible polynomial), and their cost (amount of \textbf{xor} and \textbf{xtime} operations).

\textcolor{red}{Note: this is a partial report. For the moment, it contains only Preliminaries and information about the ciphers SHARK and SQUARE. It will be expanded in the future.}

We assume the reader is familiar with:
\begin{itemize}
    \item Linear branch number (see \textcolor{red}{Chapter X})
    \item Differential branch number (see \textcolor{red}{Chapter X})
    \item Differential Cryptanalysis (see \textcolor{red}{Chapter X})
    \item Linear Cryptanalysis (see \textcolor{red}{Chapter X})
    \item MDS codes (see \textcolor{red}{Chapter X} and, for further detail, reference \cite{SloaneBook})
    \item Diffusion property in cryptography (see \textcolor{red}{Chapter X})
    \item Groups, rings and fields in abstract algebra (see \textcolor{red}{Chapter X})
\end{itemize}

\section{Notation}
\begin{itemize}
    \item $det(A)$: determinant of the matrix $A$
    \item $A^{-1}$: inverse matrix of $A$
    \item $n, k, d$: parameters of a code
    \item $\mathcal{C}$: a code
    \item $G$: generator matrix of a code
    \item $I_n$: the $n \times n$ identity matrix
    \item $[I_nB]$: matrix obtained by placing the $n \times n$ matrix $B$ to the right of the $n \times n$ identity matrix $I_n$. For example, for $B = \begin{bmatrix}1 & 2 \\ 3 & 4\end{bmatrix}$, $[I_nB] = \begin{bmatrix} 1 & 0 & 1 & 2 \\ 0 & 1 & 3 & 4\end{bmatrix}$
\end{itemize}

\section{Acronyms}
\begin{itemize}
    \item MDS: Maximum Distance Separable
    %\item SHARK: refers to the SHARK cipher \cite{SHARK1996}
    %\item SQUARE: refers to the SQUARE cipher \cite{SQUARE1997}
    %\item BKSQ: refers to the BKSQ cipher \cite{BKSQ1998}
    %\item KHAZAD: refers to the KHAZAD cipher \cite{KHAZAD2000}
    %\item ANUBIS: refers to the ANUBIS cipher \cite{ANUBIS2000}
    %\item Hierocrypt-3: refers to the Hierocrypt-3 cipher \cite{Hierocrypt2000}
    %\item Rijndael: refers to the Rijndael cipher which later became AES \cite{DesignOfRijndael2002}
    \item AES: Advanced Encryption Standard (Rijndael's name after being chosen by NIST)
    %\item Curupira: refers to the Curupira cipher \cite{barreto2007curupira}
    %\item Whirlwind: refers to the Whirlwind hash function \cite{Whirlwind2010}
    %\item Gr{\o}stl: refers to the Gr{\o}stl hash function \cite{Grostl2009}
    \item \textbf{xor}: bitwise XOR between two bit strings
    \item \textbf{xtime}: refers to the multiplication by the polynomial $x$ in the cipher's Finite Field, i.e GF($2^m$) for an integer $m$
\end{itemize}

\section{Preliminaries}
%- Explain GF arithmetic (groups, finite fields...)
%- Explain what is an irreducible polynomial
%- Definition: Hadamard matrix
%- Definition: Involutory matrix
%- Definition: circulant matrix
%- Definition: Vandermonde matrix

\subsection{Linear codes}
\begin{definition}[Hamming weight \cite{SloaneBook}]
The Hamming weight $w(x)$ of a vector $x$ is the number of nonzero components of the vector $x$.
\end{definition}

\begin{definition}[Hamming distance \cite{SloaneBook}]
The Hamming distance between two vectors $x$ and $y$ is $w(x - y)$, which is equal to the Hamming weight of the difference of the two vectors.
\end{definition}

\begin{definition}[Linear code \cite{SloaneBook}]
A linear $[n, k, d]$ code over a field $\mathbb{F}$ is a $k$-dimensional subspace of the vector space $\mathbb{F}^n$, where any two different vectors of the subspace have a Hamming distance of at least $d$, and $d$ is the largest number with this property.

The distance $d$ of a linear code equals the minimum weight of a non-zero codeword in the code. A linear code can be described by generator and/or parity-check matrices.
\end{definition}

\begin{definition}[Generator matrix \cite{SloaneBook}]
A generator matrix $G$ for an $[n, k, d]$ code $C$ is a $k \times n$ matrix whose rows form a vector space basis for $C$. The choice of a basis in a vector space is not unique, thus a code has many different generator matrices which can be reduced to one another by performing elementary row operations.
\end{definition}

\begin{definition}[Parity-check matrix \cite{SloaneBook}]
A parity-check matrix $H$ for an $[n, k, d]$ code $C$ is an $(n-k) \times k$ matrix with the property that a vector $x$ is a codeword of $C$ iff $Hx^T = 0$.
\end{definition}

\begin{definition}[Singleton Bound \cite{SloaneBook}]
If $C$ is an $[n, k, d]$ code, then $d \leq n - k + 1$.
\end{definition}

\begin{definition}[MDS code \cite{SloaneBook}]\label{def:mds-code-singleton}
An \emph{MDS code} is a \emph{linear code} that reaches the \emph{Singleton bound}.
\end{definition}

An MDS matrix associated to a $[n, k, d]$ code has \emph{branch number} equal to $d$, which is the maximum possible branch number, thus providing optimal diffusion.

\subsection{Matrices}

\textcolor{red}{Obs: eu escrevi essas primeiras definições (matriz singular, involutória, circulante, circulante à esquerda, circulante à direita) com base no que eu lembrava de matemática mesmo, então por hora ainda não coloquei uma referência bibliográfica, já que são definições mais gerais e não chegam a ser específicas de cripto. Mas posso colocar depois se necessário.}

\begin{definition}[Singular matrix]
A square matrix $A$ is singular if and only if $det(A) = 0$.
\end{definition}

\begin{definition}[Non-singular matrix]
$A$ is non-singular if and only if $det(A) \neq 0$.
\end{definition}

\begin{definition}[Involutory matrix]
An $n \times n$ square matrix $A$ is involutory if $A \times A = I_n$, where $I_n$ is the identity matrix. In other words, $A$ is involutory when $A = A^{-1}$. 
\end{definition}

\begin{definition}[Circulant matrix]
An $n \times n$ matrix $A$ is circulant if each row $i$ is formed by a cyclical shift of $i$ positions of the same set of elements $\{a_0, a_1, a_2, ..., a_{n-1}\}$.
\end{definition}

\begin{definition}[Left circulant matrix]
A circulant matrix in which the shift is a cyclical shift to the left, i.e

$$
A = 
\begin{bmatrix}
a_0 & a_1 & ... & ... & a_{n-1}\\
a_1 & a_2 & ... & a_{n-1} & a_0\\
... & ... & ... & ... & ...\\
a_{n-1} & a_0 & ... & ... & a_{n-2}
\end{bmatrix}.
$$
\end{definition}

\begin{definition}[Right circulant matrix]
A circulant matrix in which the shift is a cyclical shift to the right, i.e

$$
A = 
\begin{bmatrix}
a_0 & a_1 & ... & ... & a_{n-1}\\
a_{n-1} & a_0 & a_1 & ... & a_{n-2}\\
... & ... & ... & ... & ...\\
a_1 & ... & a_{n-2} & a_{n-1} & a_0
\end{bmatrix}.
$$
\end{definition}

Note that circulant matrices can be defined by just one row, since all the other rows are cyclical shifts of the first. Therefore, they can be denoted as $circ(a_0, a_1, ..., a_{n-1})$. In the case of left circulant and right circulant matrices, respectively, $lcirc(a_0, ..., a_{n-1})$ and $rcirc(a_0, ..., a_{n-1})$. For example, matrices (\ref{mat:rijndael}) and its inverse (\ref{mat:rijndael}), used in the Rijndael cipher, can be denoted as $rcirc(02_x, 03_x, 01_x, 01_x)$ and $rcirc(0e_x, 0b_x, 0d_x, 09_x)$.

\begin{definition}[Submatrix]
Given a matrix $M$, a submatrix of $M$ is the matrix obtained after removing $z$ rows and columns of $M$, $z \geq 1$, provided that there are sufficient rows (and columns) to be removed.
\end{definition}

\begin{theorem}[MDS codes \cite{SloaneBook}]\label{teo:mds}
An $(n, k, d)$-code $\mathcal{C}$ with generator matrix $G = [I_nB]$, where $B$ is a $k \times (n - k)$ matrix, is MDS if and only if every square submatrix of $B$ is non-singular.
\end{theorem}

We call the $B$ matrix of Theorem \ref{teo:mds} the \emph{MDS matrix} throughout this work, i.e the MDS matrices we study are the $B$ matrices of the respective MDS codes chosen when designing them.
Note that Definition \ref{def:mds-code-singleton} establishes the conditions for a code to be MDS, therefore Theorem \ref{teo:mds} is an alternative way of evaluating a code, or a matrix, with respect to the MDS property.
For further detail on matrices, determinants and linear algebra, the reader may refer to \cite{LangeLinearAlgebra}.

\begin{definition}[Cauchy matrix]\label{def:cauchy}
Given $x_0, ..., x_{n-1}$ and $y_0, ..., y_{n-1}$, the matrix $A$ where $A[i][j] = \frac{1}{x_i + y_j}$ is called a Cauchy matrix. According to \cite{Youssef1997}, provided that $x_i \neq x_j$ for $0\leq i,j\leq n-1$, that $y_i \neq y_j$ for $0\leq i,j\leq n-1$ and that $x_i + y_j \neq 0$ for all $i, j$, any square submatrix of a Cauchy matrix is nonsingular over any field.
\end{definition}

An $n\times n$ matrix posesses $n^2$ elements and thus, when constructing one e.g by selecting random elements, $n^2$ choices must be made. However, Cauchy and circulant matrices allow us to lower the number of elements we need to select. A circulant matrix can be defined by one row only, therefore only $n$ elements are required. However, there are no guarantees about the MDS property. One must check whether Theorem \ref{teo:mds} holds to ensure the obtained matrix is MDS. On the other hand, a Cauchy matrix construction directly ensures the MDS property, as can be seen in Definition \ref{def:cauchy}, requiring $2n$ choices of elements (the $x_i$ and the $y_i$) to be defined. Furthermore, it is relevant to note that, albeit most matrices in this work have their dimension $n$ be a power of two such as 4 or 8, this is not a requirement for the construction. One can construct $n \times n$ circulant (or Cauchy) matrices for any arbitrary $n$.

\begin{definition}[Hadamard matrix]
\textcolor{red}{yet to write}
\end{definition}

\begin{definition}[Vandermonde matrix]
\textcolor{red}{yet to write}
\end{definition}

%\subsubsection{Evaluating a matrix for MDS property}
%If Theorem \ref{teo:mds} is used, the determinant of the matrix itself must be calculated, as well as the determinants of its submatrices, and we must check that they are non-zero. This can be done in $O(n!^2)$ time with a recursive implementation to compute the determinants.

%\subsubsection{Computational complexity to obtain the determinant}
%The determinant of a  $2 \times 2$ matrix $\begin{bmatrix}a & b \\ c & d\end{bmatrix}$ can be computed by means of the formula $ad - bc$, requiring therefore two multiplications in the underlying Finite Field. The determinant of a $3 \times 3$ matrix can be computed by calculating cofactors of $2 \times 2$ submatrices obtained by removing a row $i$ and a column $j$. There are $3^2 = 9$ such submatrices, therefore $3^2$ determinants of $2 \times 2$ matrices are calculated --- and thus $9 \times 2 = 18$ multiplications in GF($2^m$). The determinant of a $4 \times 4$ matrix can be computed similarly by calculating the cofactors of $4^2 = 16$ submatrices which are $3 \times 3$ and thus require $3^2$ determinants of $2 \times 2$ submatrices each, therefore totalizing $4^2 \times 3^2$ determinants of $2 \times 2$ submatrices. For a $5 \times 5$ matrix, the total amount is $5^2 \times 4^2 \times 3^2$, and so forth. Therefore, for an $n \times n$ matrix, the complexity is bounded by $n!^2$ operations (in asymptotic notation, $O(n!^2)$).

\subsection{Abstract algebra}
\textcolor{red}{Aqui pretendo colocar definições de grupo, grupo abeliano, corpo etc. A parte de álgebra abstrata que não é específica de corpos finitos e que a gente geralmente vê na faculdade}

\subsection{Finite fields --- GF($2^m$)}

\begin{concept}[Finite field \cite{DesignOfRijndael2002}]
A \emph{finite field} is a field with a finite number of elements. The number of elements in the set is called the \emph{order} of the field. 
\end{concept}

\begin{concept}[Characteristic and order \cite{DesignOfRijndael2002}]
A field with order $r$ exists if and only if $r$ is a prime power, i.e $r = p^m$ for some integer $m$, where $p$ is a prime integer. $p$ is called the \emph{characteristic} of the field. For each prime power there is exactly one finite field, denoted by GF($p^m$).
\end{concept}

\begin{concept}[Representing finite fields with prime order \cite{DesignOfRijndael2002}]
Elements of a finite field GF($p$) can be represented by the integers $0, 1, ..., p - 1$, and the field operations are integer addition modulo $p$ and integer multiplication modulo $p$.
\end{concept}

\begin{concept}[Representing finite fields with non-prime order \cite{DesignOfRijndael2002}]
For finite fields with an order that is not prime, addition and multiplication cannot be represented by addition and multiplication modulo a number. One of the possible representations for GF($p^m$) is by means of \emph{polynomials over GF($p$)}.
\end{concept}

In this chapter, we focus particularly on fields with characteristic $p = 2$, due to their wide application in cryptography.

\begin{concept}[Polynomial \cite{DesignOfRijndael2002}]
A polynomial over a field $\mathbb{F}$ is an expression of the form

$$
b(x) = b_{m-1}x^{m-1} + b_{m-2}x^{m-2} + ... + b_2x^2 + b_1x + b_0,
$$

where $x$ is the \emph{indeterminate} and $b_i \in \mathbb{F}$ are the coefficients. The \emph{degree} of the polynomial equals $l$ if $b_j = 0$ for all $j > l$ and $l$ is the smallest number with this property.
\end{concept}

Addition and multiplication are defined on polynomials as follows.

\begin{concept}[Polynomial addition \cite{DesignOfRijndael2002}]
Summing two polynomials $a(x)$ and $b(x)$ consists of summing the coefficients with equal powers of $x$, with the sum occuring in the underlying field $\mathbb{F}$. The neutral element is 0 (the polynomial with all coefficients equal to 0). The inverse element can be found by replacing each coefficient by its inverse element in $\mathbb{F}$. The degree of $a(x) + b(x)$ is at most the maximum of the degrees of $a(x)$ and $b(x)$, therefore addition is closed.
\end{concept}

For polynomials over GF($2$) stored as integers in a cryptographic software implementation, addition can be implemented with a bitwise XOR instruction.

\begin{concept}[Polynomial multiplication \cite{DesignOfRijndael2002}]
In order to make multiplication closed, we select a polynomial $p(x)$ of degree $l$, called the \emph{reduction polynomial}. Multiplication of $a(x)$ and $b(x)$ is then defined as the algebraic product of the polynomials modulo the reduction polynomial $p(x)$.

The neutral element is 1 (the polynomial of degree 0 and with coefficient of $x^0$ equal to 1). The inverse element of $a(x)$ is $a^{-1}(x)$ such that $a(x) \times a^{-1}(x) = 1$. Note that $a^{-1}(x)$ exists only when $a(x) \neq 0$.
\end{concept}

For polynomials over GF($2$) stored as integers in a cryptographic software implementation, multiplication by $x$ can be implemented as a logical bit shift followed by conditional XOR (i.e subtraction) of the reduction polynomial (the \textbf{xtime} operation). Multiplication by other polynomials can be implemented as a series of \textbf{xtime}.

The reduction polynomial is chosen as an irreducible polynomial.

\begin{concept}[Irreducible polynomial \cite{DesignOfRijndael2002}]
A polynomial $d(x)$ is irreducible over the field GF($p$) if and only if there exist no two polynomials $a(x)$ and $b(x)$ with coefficients in GF($p$) such that $d(x) = a(x) \times b(x)$, where $a(x)$ and $b(x)$ are of degree greater than 0.
\end{concept}

For further reference on abstract algebra and Finite Fields, the reader may refer to \cite{panario2007topicos}, \cite{panario2013handbook} and \cite{Handbook1996}.

\subsection{Computational cost unit}\label{sec:comp-cost}

\subsubsection{Computational cost of multiplication in GF($2^8$)}
Consider $T$ a state byte, which we multiply by the polynomial $2e_x = 00101110_2 = x^5 + x^3 + x^2 + x$ in GF($2^8$). Note that 

$$
T \cdot 2e_x = T \cdot x^5 + T \cdot x^3 + T \cdot x^2 + T \cdot x = T \cdot x \cdot x \cdot x \cdot x \cdot x + T \cdot x \cdot x \cdot x + T \cdot x \cdot x + T \cdot x,
$$

where $\cdot$ denotes multiplication and $+$ denotes addition (which, in GF($2^8$), is equivalent to a bitwise XOR). Multiplication by the $x$ polynomial is performed by \textbf{xtime}, and addition is performed by \textbf{xor}.

Let $T \cdot x = Y$. Then $T \cdot 2e_x = Y + Y \cdot x + Y \cdot x \cdot x + Y \cdot x \cdot x \cdot x \cdot $.

Let $Y \cdot x = W$. Then $T \cdot 2e_x = Y + W + W \cdot x + W \cdot x \cdot x \cdot x$.

Let $W \cdot x = Z$. Then $T \cdot 2e_x = Y + W + Z + Z \cdot x \cdot x$.

The total number of \textbf{xtime} operations in this process is 5 (1 to obtain $Y$ from $T$, 1 to obtain $W$ from $Y$, 1 to obtain $Z$ from $W$, 2 to compute $Z \cdot x \cdot x$), since we can reuse intermediate \textbf{xtime} calls. The total number of \textbf{xor} operations is 3. For multiplication in GF($2^8$), in the worst case, 7 \textbf{xtime} would be necessary, since the maximum degree of polynomials in GF($2^8$) is 7.

\subsubsection{Computational cost of a matrix}
The computational cost of an $n\timesn$ matrix $A$ is given by the necessary \textbf{xor} and \textbf{xtime} operations when multiplying a $n\times1$ column vector by $A$. As an example, we calculate the cost of matrix (\ref{mat:square}), used in the SQUARE \cite{SQUARE1997} cipher. 

A row of matrix (\ref{mat:square}) contains the elements $01_x = 1, 02_x = x$ and $03_x = x + 1$ only. Multiplying by $01_x$ does not require \textbf{xtime} or \textbf{xor}, since $01_x \cdot T = T$. Computing $02_x \cdot T = x \cdot T$ requires 1 \textbf{xtime}. Computing $03_x \cdot T = (x + 1) \cdot T = T \cdot x + T$ requires 1 \textbf{xtime} and 1 \textbf{xor}. Furthermore, adding the row multiplication results costs 3 \textbf{xor}. Therefore, the cost of a row is 2 \textbf{xtime} and 4 \textbf{xor}. Equation \ref{eq:cost} illustrates this, with $t_1, t_2, t_3$ and $t_4$ being bytes of the state column vector.

\begin{equation}\label{eq:cost}
\begin{bmatrix}
02_x & 01_x & 01_x & 03_x\\
\end{bmatrix}
\cdot 
\begin{bmatrix}
t_1\\
t_2\\
t_3\\
t_4
\end{bmatrix}
= 02_x \cdot t_1 + 01_x \cdot t_2 + 01_x \cdot t_3 + 03_x \cdot t_4
\end{equation}

Note that matrix (\ref{mat:square}) contains 4 rows, yielding a total cost of 8 \textbf{xtime} and 16 \textbf{xor}.

\section{MDS matrix catalogue}

In Table \ref{tbl:mds-list}, the \textbf{Ord} column refers to the matrix dimensions, the \textbf{Inv} column refers to whether they are involutory or not, \textbf{\#xor} refers to the necessary amount of \textbf{xor} operations, and \textbf{\#xtime} refers to the necessary amount of \textbf{xtime} operations. All finite fields of Table \ref{tbl:mds-list} have characteristic $p = 2$. The order is $2^m$, with $m$ being given by the degree of the irreducible polynomial in the column $GF(2)[x]/(p(x))$. For example, $m = 8$ for SHARK, SQUARE, BKSQ, KHAZAD, ANUBIS, Hierocrypt, Rijndael and the Cauchy matrix found by \cite{Youssef1997}.

\begin{footnotesize}
\begin{longtable}[c]{|l|l|l|l|l|l|l|l|l|}
\hline
\textbf{Year} & \textbf{Ord} & \textbf{Type} & \textbf{Inv} & \textbf{Use} & \textbf{$GF(2)[x]/(p(x))$} & \textbf{\#xor} & \textbf{\#xtime} & \textbf{Matrices} \\ \hline
\endfirsthead
\endhead
% row template
% year & type & inv & use & poly & xor & xtime & mats
% SHARK
1996 & 8 & --- & no & \shortstack{SHARK \cite{SHARK1996}} & \shortstack{$x^8 + x^7 + x^6 + x^5$\\$+ x^4 + x^2 + 1$} & \shortstack{235 \\223} & \shortstack{369 \\393} & \shortstack{\\ \ref{mat:shark} \\ \ref{mat:shark-inv}} \\ \hline
% SQUARE
1997 & 4 & \shortstack{\\ right \\ circulant} & no & \shortstack{SQUARE \cite{SQUARE1997}} & \shortstack{$x^8 + x^7 + x^6 + x^5$\\$+ x^4 + x ^2 + 1$} & \shortstack{16 \\40} & \shortstack{8 \\ 48} & \shortstack{\\ \ref{mat:square} \\ \ref{mat:square-inv}} \\ \hline
% Tavares
1997 & 8 & Cauchy & yes & \shortstack{\cite{Youssef1997}} & \shortstack{$x^8 + x^4 + x^3$\\$+ x^2 + 1$} & 240 & 344 & \ref{mat:tavares} \\ \hline
% BKSQ
1998 & 3 & \shortstack{\\ right \\ circulant} & no & \shortstack{BKSQ \cite{BKSQ1998}} & \shortstack{$x^8 + x^7 + x^6 + x^5$\\$+ x^4 + x ^2 + 1$} & 9 & 9 & \shortstack{\\ \ref{mat:bksq} \\ \ref{mat:bksq-inv}} \\ \hline
% Rijndael
1999 & 4 & \shortstack{\\ right \\ circulant} & no & \shortstack{Rijndael \\ (AES) \cite{DesignOfRijndael2002}} & \shortstack{$x^8 + x^4 + x^3$\\$+ x + 1$} & \shortstack{16,\\40} & \shortstack{8, \\48} & \shortstack{\\ \ref{mat:rijndael}, \\ \ref{mat:rijndael-inv}} \\ \hline
% KHAZAD
2000 & 8 & Hadamard & yes & \shortstack{KHAZAD \cite{KHAZAD2000}} & \shortstack{$x^8 + x^4 + x^3$\\$+ x^2 + 1$} & 112 & 120 & \ref{mat:khazad} \\ \hline
% ANUBIS
2000 & 4 & Hadamard & yes & \shortstack{ANUBIS \cite{ANUBIS2000}} & \shortstack{$x^8 + x^4 + x^3$\\$+ x^2 + 1$} & 16 & 20 & \ref{mat:anubis} \\ \hline
% Hierocrypt
2000 & ord & type & inv & \shortstack{Hierocrypt-3 \cite{Hierocrypt2000}} & poly & xor & xtime & mat \\ \hline
% Curupira
2007 & ord & type & inv & \shortstack{Curupira \cite{barreto2007curupira}} & poly & xor & xtime & mat \\ \hline
% Grostl
2009 & ord & type & inv & \shortstack{Gr{\o}stl \cite{Grostl2009}} & poly & xor & xtime & mat \\ \hline
% Whirlwind
2010 & ord & type & inv & \shortstack{Whirlwind \cite{Whirlwind2010}} & poly & xor & xtime & mat \\ \hline
\caption{MDS matrix usage and cost}\label{tbl:mds-list}
\end{longtable}
\end{footnotezize}

Matrix (\ref{mat:shark}) and its inverse (\ref{mat:shark-inv}) are used in the SHARK \cite{SHARK1996} cipher.

\begin{equation}\label{mat:shark}
\begin{bmatrix}
ce_x & 95_x & 57_x & 82_x & 8a_x & 19_x & b0_x & 01_x\\ 
e7_x & fe_x & 05_x & d2_x & 52_x & c1_x & 88_x & f1_x\\
b9_x & da_x & 4d_x & d1_x & 9e_x & 17_x & 83_x & 86_x\\
d0_x & 9d_x & 26_x & 2c_x & 5d_x & 9f_x & 6d_x & 75_x\\
52_x & a9_x & 07_x & 6c_x & b9_x & 8f_x & 70_x & 17_x\\
87_x & 28_x & 3a_x & 5a_x & f4_x & 33_x & 0b_x & 6c_x\\
74_x & 51_x & 15_x & cf_x & 09_x & a4_x & 62_x & 09_x\\
0b_x & 31_x & 7f_x & 86_x & be_x & 05_x & 83_x & 34_x
\end{bmatrix}
\end{equation}

\begin{equation}\label{mat:shark-inv}
\begin{bmatrix}
e7_x &30_x &90_x &85_x &d0_x &4b_x &91_x &41_x\\
53_x &95_x &9b_x &a5_x &96_x &bc_x &a1_x &68_x\\
02_x &45_x &f7_x &65_x &5c_x &1f_x &b6_x &52_x\\
a2_x &ca_x &22_x &94_x &44_x &63_x &2a_x &a2_x\\
fc_x &67_x &8e_x &10_x &29_x &75_x &85_x &71_x\\
24_x &45_x &a2_x &cf_x &2f_x &22_x &c1_x &0e_x\\
a1_x &f1_x &71_x &40_x &91_x &27_x &18_x &a5_x\\
56_x &f4_x &af_x &32_x &d2_x &a4_x &dc_x &71_x
\end{bmatrix}
\end{equation}

Matrix (\ref{mat:square}) and its inverse (\ref{mat:square-inv}) are used in the SQUARE \cite{SQUARE1997} cipher. They are circulant.

\begin{equation}\label{mat:square}
\begin{bmatrix}
02_x & 01_x & 01_x & 03_x\\ 
03_x & 02_x & 01_x & 01_x\\
01_x & 03_x & 02_x & 01_x\\
01_x & 01_x & 03_x & 02_x
\end{bmatrix}
\end{equation}

\begin{equation}\label{mat:square-inv}
\begin{bmatrix}
0e_x & 09_x & 0d_x & 0b_x\\
0b_x & 0e_x & 09_x & 0d_x\\
0d_x & 0b_x & 0e_x & 09_x\\
09_x & 0d_x & 0b_x & 0e_x
\end{bmatrix}
\end{equation}

Matrix (\ref{mat:tavares}) is involutory, and was obtained by \cite{Youssef1997} with a Cauchy construction.

\begin{equation}\label{mat:tavares}
\begin{bmatrix}
93_x & 13_x & 57_x & da_x & 58_x & 47_x & 0c_x & 1f_x\\
13_x & 93_x & da_x & 57_x & 47_x & 58_x & 1f_x & 0c_x\\
57_x & da_x & 93_x & 13_x & 0c_x & 1f_x & 58_x & 47_x\\
da_x & 57_x & 13_x & 93_x & 1f_x & 0c_x & 47_x & 58_x\\
58_x & 47_x & 0c_x & 1f_x & 93_x & 13_x & 57_x & da_x\\
47_x & 58_x & 1f_x & 0c_x & 13_x & 93_x & da_x & 57_x\\
0c_x & 1f_x & 58_x & 47_x & 57_x & da_x & 93_x & 13_x\\
1f_x & 0c_x & 47_x & 58_x & da_x & 57_x & 13_x & 93_x
\end{bmatrix}
\end{equation}

Matrix (\ref{mat:khazad}) is Hadamard and involutory. It is used in the KHAZAD \cite{KHAZAD2000} cipher.

\begin{equation}\label{mat:khazad}
\begin{bmatrix}
01_x & 03_x & 04_x & 05_x & 06_x & 08_x & 0b_x & 07_x\\
03_x & 01_x & 05_x & 04_x & 08_x & 06_x & 07_x & 0b_x\\
04_x & 05_x & 01_x & 03_x & 0b_x & 07_x & 06_x & 08_x\\
05_x & 04_x & 03_x & 01_x & 07_x & 0b_x & 08_x & 06_x\\
06_x & 08_x & 0b_x & 07_x & 01_x & 03_x & 04_x & 05_x\\
08_x & 06_x & 07_x & 0b_x & 03_x & 01_x & 05_x & 04_x\\
0b_x & 07_x & 06_x & 08_x & 04_x & 05_x & 01_x & 03_x\\
07_x & 0b_x & 08_x & 06_x & 05_x & 04_x & 03_x & 01_x
\end{bmatrix}
\end{equation}

Matrix (\ref{mat:anubis}) is Hadamard and involutory. It is used in the ANUBIS \cite{ANUBIS2000} cipher.

\begin{equation}\label{mat:anubis}
\begin{bmatrix}
01_x & 02_x & 04_x & 06_x\\
02_x & 01_x & 06_x & 04_x\\
04_x & 06_x & 01_x & 02_x\\
06_x & 04_x & 02_x & 01_x
\end{bmatrix}
\end{equation}

Still regarding the ANUBIS cipher, while (\ref{mat:anubis}) is used as its linear transformation layer, (\ref{mat:anubis-ke}) is used in the key extraction. It is a Vandermonde construction. When $N = 4$, it is an MDS matrix.

\begin{equation}\label{mat:anubis-ke}
\begin{bmatrix}
01_x & 01_x & 01_x & ... & 01_x\\
01_x & 02_x & 02_x^2 & ... & 02_x^{N-1}\\
01_x & 06_x & 06_x^2 & ... & 06_x^{N-1}\\
01_x & 08_x & 08_x^2 & ... & 06_x^{N-1}
\end{bmatrix}
\end{equation}

Matrix (\ref{mat:rijndael}) and its inverse (\ref{mat:rijndael-inv}) are used in the Rijndael \cite{DesignOfRijndael2002} cipher, which was selected to become AES. They are circulant. We show the hexadecimal notation and the corresponding polynomials to enphasize that, albeit stored as integers in cryptographic software implementation, all matrix elements are actually polynomials in a Finite Field. This applies not only to the Rijndael cipher's matrices but to all matrices listed in this work.

\begin{equation}\label{mat:rijndael}
\begin{bmatrix}
02_x & 03_x & 01_x & 01_x\\
01_x & 02_x & 03_x & 01_x\\
01_x & 01_x & 02_x & 03_x\\
03_x & 01_x & 01_x & 02_x
\end{bmatrix}
=
\begin{bmatrix}
x & x+1 & 1 & 1\\
1 & x & x+1 & 1\\
1 & 1 & x & x+1\\
x+1 & 1 & 1 x
\end{bmatrix}
\end{equation}

\begin{equation}\label{mat:rijndael-inv}
\begin{bmatrix}
0e_x & 0b_x & 0d_x & 09_x\\
09_x & 0e_x & 0b_x & 0d_x\\
0d_x & 09_x & 0e_x & 0b_x\\
0b_x & 0d_x & 09_x & 0e_x
\end{bmatrix}
=
\begin{bmatrix}
x^3+x^2+x & x^3+x+1 & x^3+x^2+1 & x^3+1\\
x^3+1 & x^3+x^2+x & x^3+x+1 & x^3+x^2+1\\
x^3+x^2+1 & x^3+1 & x^3+x^2+x & x^3+x+1\\
x^3+x+1 & x^3+x^2+1 & x^3+1 & x^3+x^2+x
\end{bmatrix}
\end{equation}

Matrix (\ref{mat:bksq}) is used in the BKSQ \cite{BKSQ1998} cipher. It is circulant.

\begin{equation}\label{mat:bksq}
\begin{bmatrix}
03_x & 02_x & 02_x\\
02_x & 03_x & 02_x\\
02_x & 02_x & 03_x
\end{bmatrix}
\end{equation}

%\begin{equation}\label{mat:bksq-inv}
%\begin{bmatrix}
%ac_x & ad_x & ad_x\\
%ad_x & ac_x & ad_x\\
%ad_x & ad_x & ac_x
%\end{bmatrix}
%\end{equation}

\section{Computing \textbf{xtime} and \textbf{xor} of the matrices}

One can compute the costs manually, however, the following following C code can also be used for this purpose, considering that polynomials in GF($2^8$) are stored in integers (a set bit means coefficient equal to 1, a zero bit means coefficient equal to 0).

For e.g SHARK and SQUARE, the field order is equal to 8, therefore \texttt{ORDER} must be set to 8 and \texttt{DEGREE_LIMIT_MASK} must be set to $x^8$.

\begin{minted}{C}
#define DEGREE_LIMIT_MASK 0x100
#define ORDER 8
\end{minted}

The following function obtains the amount of \textbf{xtime} required to multiply by the polynomial.

\begin{minted}{C}
unsigned int poly_xtime_cost(unsigned int poly) {
	unsigned int degree_mask = DEGREE_LIMIT_MASK;
	unsigned int degree = ORDER;
	while ((poly & degree_mask) == 0) {
		degree_mask >>= 1;
		degree--;
	}
	return degree;
}
\end{minted}

The following function obtains the amount of \textbf{xor} required to multiply by the polynomial.
\begin{minted}{C}
unsigned int poly_xor_cost(unsigned int poly) {
	unsigned int mask = 1;
	unsigned int set_bits = 0;
	unsigned int current_bit = 0;
	while (current_bit <= ORDER) {
		set_bits += ((poly & mask) != 0);
		mask <<= 1;
		current_bit++;
	}
	return set_bits - 1;
}
\end{minted}

And, to compute the \textbf{xtime} and \textbf{xor} costs of a matrix, we must sum the costs of each row, which is accomplished by the following functions. Note that for e.g SHARK \texttt{DIM} must be set to 8, for SQUARE, to 4, and so forth.

\begin{minted}{C}
#define DIM 8

unsigned int matrix_xtime_cost(unsigned int mat [DIM][DIM]) {
	unsigned int total_cost = 0;
	for (int row = 0; row < DIM; row++) {
		unsigned int row_cost = 0;
		for (int col = 0; col < DIM; col++) {
			row_cost += poly_xtime_cost(mat[row][col]);
		}
		printf("Row %d costs %d xtime\n", row, row_cost);
		total_cost += row_cost;
	}
	printf("The full matrix costs %d xtime\n", total_cost);
	return total_cost;
}

unsigned int matrix_xor_cost(unsigned int mat[DIM][DIM]) {
	unsigned int total_cost = 0;
	for (int row = 0; row < DIM; row++) {
		unsigned int row_cost = DIM - 1; //sum elements
		for (int col = 0; col < DIM; col++) {
			row_cost += poly_xor_cost(mat[row][col]);
		}
		printf("Row %d costs %d xor\n", row, row_cost);
		total_cost += row_cost;
	}
	printf("The full matrix costs %d xor\n", total_cost);
	return total_cost;
}
\end{minted}

\subsection{SQUARE manual calculation example}
The computational cost for matrix (\ref{mat:shark}), used in the SQUARE cipher, was explained in Section \ref{sec:comp-cost}.

For matrix (\ref{mat:square-inv}), used in SQUARE's decryption process, each row contains elements from $\{0e_x, 09_x, 0d_x, 0b_x\}$. 

\begin{equation*}
0e_x = 00001110_2 = x^3 + x^2 + x \text{ requires 3 \textbf{xtime} and 2 \textbf{xor} }
\end{equation*}

\begin{equation*}
09_x = 00001001_2 = x^3 + 1 \text{ requires 3 \textbf{xtime} and 1 \textbf{xor} }
\end{equation*}

\begin{equation*}
0d_x = 00001101_2 = x^3 + x^2 + 1 \text{ requires 3 \textbf{xtime} and 2 \textbf{xor} }
\end{equation*}

\begin{equation*}
0b_x = 00001011_2 = x^3 + x + 1 \text{ requires 3 \textbf{xtime} and 2 \textbf{xor} }
\end{equation*}

There are 3 \textbf{xor} to add the intermediate row multiplication results, totalizing 12 \textbf{xtime} and 10 \textbf{xor} per row. There are 4 rows, hence 48 \textbf{xtime} and 40 \textbf{xor}.

\section{Conclusions}
\textcolor{red}{yet to be written}

\bibliographystyle{plain}
\bibliography{refs}

\end{document}
